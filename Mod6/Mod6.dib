#!markdown

# 6.1. Ссылочные и значимые типы данных. Структуры и объекты

#!markdown

## Стек и Куча

**Значимый тип** — тип, значение которого хранится в ***стеке***.

**Ссылочный тип** — тип, значение которого хранится в ***куче***, а в *стеке* хранится **ссылка** на адрес в *куче*.

#!markdown

# 6.2. Классы и структуры

#!markdown

## Расположение классов

В C# возможно определять классы (и структуры) как в пространстве имен, так и внутри других классов:

#!csharp

  public class FirstOOPApp
  {
    class ExternalClass
    {
      public class ClassInternalClass
      {
      }

      struct ClassInternalStruct
      {
      }
    }

    class ExternalStruct
    {
      class StructInternalClass
      {
      }

      public struct StructInternalStruct
      {
      }
    }

    class Program
    {
      static void Main(string[] args)
      {

        ExternalClass.ClassInternalClass newClass;
        ExternalStruct.StructInternalStruct newStruct;
      }
    }
  }

#!markdown

## Конструкторы

Помимо полей и методов классы и структуры могут содержать конструкторы.
Конструктор — специальный метод, имеющий одно название с классом (структурой), который вызывается при создании нового объекта данного класса (структуры).

#!markdown

## Создание конструкторов

Помимо конструктора по умолчанию пользователь может создавать свои конструкторы. Как уже говорилось ранее, конструктор — это метод, который имеет одно название с классом (структурой), для которого он определен. Определим несколько конструкторов для класса Human:

#!csharp

using System;

  class Human
  {
    // Поля класса
    public string name;
    public int age;

    // Метод класса
    public void Greetings()
    {
      Console.WriteLine("Меня зовут {0}, мне {1}", name, age);
    }
    // Конструктор 1
    public Human()
    {
      name = "Неизвестно";
      age = 20;
    }
    // Конструктор 2
    public Human(string n)
    {
      name = n;
      age = 20;
    }
    // Конструктор 3
    public Human(string n, int a)
    {
      name = n;
      age = a;
    }

  }

  struct Animal
  {
    // Поля структуры
    // public Animal(string type, string name, int age)
    // {
    //   this.type = type;
    //   this.name = name;
    //   this.age = age;
    // }
    public string type;
    public string name;
    public int age;

    // Метод структуры
    public void Info()
    {
      Console.WriteLine("Это {0} по кличке {1}, ему {2}", type, name, age);
    }
  }
  Human human = new Human();
  human.Greetings();

  human = new Human("Дмитрий");
  human.Greetings();

  human = new Human("Дмитрий", 23);
  human.Greetings();

#!csharp

static void AddTen(ref int num)
{
  num = num + 10;
}
var num = 1;
AddTen(ref num);
Console.WriteLine(num);

#!csharp

  class Pen
  {

    public string color;
    public int cost;
    public Pen()
    {
      color = "Черный";
      cost = 100;
    }
    public Pen(string color, int cost)
    {
      this.color = color;
      this.cost = cost;
    }
  }
      Pen pen1 = new Pen();
      System.Console.WriteLine(pen1.color +" "+ pen1.cost);
      Pen pen2 = new Pen("White", 200);
      System.Console.WriteLine(pen2.color +" "+  pen2.cost);

#!markdown

## Инициализаторы

Помимо явного вызова конструкторов для инициализации объектов можно воспользоваться инициализаторами.
Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта.

### **Важно отметить:**

  - С помощью инициализатора можно устанавливать значения только доступных из внешнего кода полей и свойств объекта (которые помечены ключевым словом public).
  - Если в конструкторе устанавливаются значения полей, которые указаны в инициализаторе, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

#!markdown

## Задание 6.2.3

Для структуры Animal напишите выражение для создания экземпляра с инициализатором, заполнив поля type значением "Собака", name — "Вольт", age — 4. Поля обязательно должны быть в таком же порядке.
Выражение для ответа должно находиться в правой части присвоения, то есть вместо знаков ??? в выражении Animal animal = ??? .

#!csharp

  struct Animal
  {
    // Поля структуры
    // public Animal(string type, string name, int age)
    // {
    //   this.type = type;
    //   this.name = name;
    //   this.age = age;
    // }
    public string type;
    public string name;
    public int age;

    // Метод структуры
    public void Info()
    {
      Console.WriteLine("Это {0} по кличке {1}, ему {2}", type, name, age);
    }
  }

    Animal animal = new Animal { type = "Собака", name = "Вольт", age = 4 };
  // animal.type = "Собака"; animal.name = "Вольт"; animal.age = 4;
  animal.Info();

#!markdown

## Задание 6.2.8

Создайте класс Rectangle для представления прямоугольников удовлетворяющий следующим требованиям:

  - Класс должен содержать целочисленные поля для сторон a и b.
  - Класс должен содержать метод Square, возвращающий площадь прямоугольника (произведение сторон).
  - Класс должен содержать 3 конструктора: с 2 параметрами, когда a != b, с 1 параметром, когда a == b, и конструктор без параметров по умолчанию, в котором стороны будут заполняться как a = 6, b = 4.

#!csharp

  class Rectangle
  {
    public int a;
    public int b;

    public Rectangle()
    {
      a = 6;
      b = 4;
    }

    public Rectangle(int side)
    {
      a = side;
      b = side;
    }

    public Rectangle(int first, int second)
    {
      a = first;
      b = second;
    }

    public int Square()
    {
      return a * b;
    }
  }

  Rectangle sq = new Rectangle(5);
  Console.WriteLine(sq.Square());

#!markdown

# 6.3. Особенности работы со ссылочными и значимыми типами данных

#!markdown

## Значение null

#!csharp

Human human = null;

if (human != null)
{
	Console.WriteLine(human.age);
}

#!markdown

Данное выражение можно сократить с помощью null-условного оператора (или оператора распространения null).

Для этого следует добавить знак ? к объекту, который может быть равен null, и дальше продолжить использовать его поля:

#!csharp

Human human = null;
Console.WriteLine(human?.age);

#!csharp

class Employee
{
	public Department Department;
}

class Department
{
	public Company Company;
}

class Company
{
	public string Name;
}
// поскольку все классы ссылочного типа, нам нужно проверить их на null:
Employee employee = new Employee();
string name = employee?.Department?.Company?.Name;

#!markdown

## Также вам пригодится оператор null-объединения, или оператор ??. Данный оператор возвращает левый операнд, если этот операнд не равен null, иначе — правый. При этом левый операнд должен принимать null.

#!csharp

object first = null;
object second = first ?? 100;
Human human = null;
Human newHuman = human ?? new Human("Дмитрий", 23);

#!markdown

Но данный оператор нельзя применять со значимыми типами, поскольку они не могут хранить значение null. То есть такой код выдаст ошибку компиляции:

        int one = 1;
        int two = one ?? 2;

#!markdown

## Задание 6.3.1

Вам даны следующие классы:

    class Company
    {
      public string Type;
      public string Name;
    }

    class Department
    {
      public Company Company;
      public City City;
    }

    class City
    {
      public string Name;
    }

И экземпляр класса Department, полученный из метода GetCurrentDepartment (логика работы метода опущена):

    class Program
    {
      static void Main(string[] args)
      {
        var department = GetCurrentDepartment();
      }

      static Department GetCurrentDepartment()
      {
        // logic
      }
    }

Напишите такой код, который бы при типе компании, равному типу "Банк", и городе "Санкт-Петербург" выводил в консоль сообщение "У банка ??? есть отделение в Санкт-Петербурге", где вместо "???" выводилось бы название компании.

Если у компании нет названия, вместо него должно быть "Неизвестная компания".

#!csharp

class Company
{
	public string Type;
	public string Name;
}

class Department
{
	public Company Company;
	public City City;
}

class City
{
	public string Name;
}

// class Program
// {
// 	static void Main(string[] args)
// 	{
//   }
  
// }
static Department GetCurrentDepartment()
{
  // logic
}
var department = GetCurrentDepartment();
if (department?.Company?.Type == "Банк" && department?.City?.Name == "Санкт-Петербург")
{
Console.WriteLine("У банка {0} есть отделение в Санкт-Петербурге", department?.Company?.Name ?? "Неизвестная компания");
}

#!markdown

## Задание 6.3.2

Для класса Bus реализуйте метод PrintStatus, который будет сообщать о количестве пассажиров в автобусе, если они есть. Или сообщать, что автобус пуст.

    class Bus
    {
      public int? Load;

      public void PrintStatus()
      {

      }
    }

#!csharp

class Bus
{
	public int? Load;

public Bus(){
 
}
public Bus(int load){
  this.Load = load;
}
	public void PrintStatus()
	{
	if (Load.HasValue)
	{
		Console.WriteLine("В авбтобусе {0} пассажиров", Load.Value);
	}
	else
	{
		Console.WriteLine("Автобус пуст!");
	}
	}
}
Bus bus = new Bus();
Bus bus1 = new Bus(1);
bus.PrintStatus();
bus1.PrintStatus();

#!markdown

# 6.4. Упаковка и распаковка

**Упаковка** — процесс преобразования объекта значимого типа в объект типа ***object***. При этом значение объекта заносится в управляемую кучу.

**Распаковка** — обратный упаковке процесс, когда из упакованного объекта типа ***object*** создается объект изначального типа. При этом значение объекта переносится из управляемой кучи в стек.

Упаковка и распаковка ресурсозатратны, поскольку требуют выделения памяти и приведения типов. Поэтому данных операций стараются избегать, когда это возможно. Одним из инструментов, который позволяет это делать являются обобщения (или обобщенные типы, Generic-типы), о которых мы поговорим в следующем модуле.
Целесообразность оптимизации появляется, как правило, тогда, когда операции упаковки и распаковки предстоит производить в цикле сотни и тысячи раз. В ином случае не стоит бояться падения производительности, поскольку оно не будет ощутимым.

#!markdown

# 6.5. Введение в ООП

**Абстрагирование** — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция — это использование всех таких характеристик для описания объекта.

#!markdown

## Задание 6.5.2

Опишите классы C# для следующих геометрических объектов: треугольник, круг, квадрат.

В классах нужно объявить поля для длин сторон (радиус) и методы для получения площади и периметра (длины окружности) без их реализации и без конструкторов.

#!csharp

class Circle
{
	public double radius;

	public double Square()
	{
	}

	public double Length()
	{
	}
}

class Triangle
{
	public int a;
	public int b;
	public int c;

	public double Square()
	{
	}

	public double Perimeter()
	{
	}
}

class Square
{
	public int side;

	public double Square()
	{
	}

	public double Perimeter()
	{
	}
}

#!markdown

# 6.6. Инкапсуляция

### **Инкапсуляция** — это объединение и изолирование всех данных и процессов объекта внутри единой структуры.

## Библиотека классов

### **Библиотека классов** — это определенный тип проектов в .Net, который позволяет переиспользовать свой код в других приложениях в виде подключаемых модулей.

Библиотека классов компилируется в сборку и уже в таком виде подключается к другим частям приложения при его работе.

### **Сборка** является базовой структурной единицей в .Net, на уровне которой проходит контроль версий, развертывание и конфигурация приложения.

#!markdown

## Свойства

Помимо методов и полей в классах язык C# предусматривает использование специальных элементов, находящихся где-то между. Они называются свойства.

### **Свойства** являются специальными членами классов (и структур), которые позволяют получать и изменять значение приватного поля, применяя некоторую логику для проверки (валидации) действий.

#!csharp

class User
{
	private int age;

	public int Age
	{
		get
		{
			return age;
		}

		set
		{
			age = value;
		}
	}
}

#!markdown

В данном случае публичным свойством является public int Age, которое работает с приватным полем. Специальные конструкции: get {} — геттер и set {} — сеттер работают при обращении для чтения и записи в поле. Параметр value представляет передаваемое значение.

#!markdown

## Свойства только для чтения и только для записи

Блоки **set** и **get** необязательно одновременно должны присутствовать в свойстве. Если свойство определяет только блок **get**, то такое свойство доступно ***только для чтения*** — мы можем получить его значение, но не установить. И наоборот, если свойство имеет только блок **set**, тогда это свойство доступно ***только для записи*** — можно только установить значение, но нельзя получить:

#!csharp

class User
{
	private string login;
	private DateTime lastSeen;

	// Read-only
	public string Login
	{
		get
		{
			return login;
		}
	}

	// Write-only
	public DateTime LastSeen
	{
		set
		{
			lastSeen = value;
		}
	}
}

#!markdown

### Важно соблюдать следующие правила:

  - Модификатор для блока set или get можно установить, если свойство имеет оба блока (и **set**, и **get**).
  - Только один из блоков **set/get** может иметь модификатор доступа, но не оба сразу.
  - Модификатор доступа блока **set/get** должен быть более ограничивающим, чем модификатор доступа свойства. Например, если свойство имеет модификатор ***public***, то блок **set/get** может иметь только модификаторы, с использованием которых блок будет менее доступен: **protected internal**, **internal**, **protected**, **private**.

#!markdown

## Автоматические свойства

C# позволяет сокращать запись свойств там, где не нужно использовать особую логику, но нужно управлять доступом к полям. С помощью автоматических свойств можно писать свойства в 1 строку, не уступая по объему объявлению полей:

		class User
		{
			public string Login { get; set; }
			public int Age { get; set; }
		}

На самом деле тут также создаются поля для свойств, только их создает не программист в коде, а компилятор автоматически генерирует при компиляции.

Преимущество автосвойств в том, что в любой момент времени при необходимости мы можем развернуть автосвойство в обычное свойство, добавить в него какую-то определенную логику.

Несмотря на всю схожесть работы с обычными свойствами, нельзя создать автоматическое свойство только для записи, как в случае со стандартными свойствами.

Автосвойства также могут иметь модификаторы доступа:

		class User
		{
			public string Login { get; private set; }
			public int Age { private get; set; }
		}
